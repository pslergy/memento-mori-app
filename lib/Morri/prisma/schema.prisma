// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// üë§ USER MODEL
// =============================================================================

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  username     String   @unique
  
  passwordHash String
  recoveryMnemonicHash String?

  // Mesh & Karma
  ghostId      String?  @unique 
  karma        Int      @default(0) 
  fcmToken     String?  

  countryCode  String
  gender       Gender
  dateOfBirth  DateTime
  deathDate    DateTime
  lifestyle    Json?

  createdAt    DateTime @default(now())

  // Relations
  friendsAsA        Friendship[]   @relation("friendsAsUserA")
  friendsAsB        Friendship[]   @relation("friendsAsUserB")
  chatRooms         ChatParticipant[]
  sentMessages      Message[]
  reportsMade       Report[]       @relation("ReportsMadeByUser")
  reportsAbout      Report[]       @relation("ReportsAboutUser")
  ownedChannelRooms ChatRoom[]     @relation("ChannelOwner")
  isShadow          Boolean        @default(false)
}

// =============================================================================
// ü§ù FRIENDSHIP
// =============================================================================

model Friendship {
  userA_id String
  userB_id String
  userA    User   @relation("friendsAsUserA", fields: [userA_id], references: [id])
  userB    User   @relation("friendsAsUserB", fields: [userB_id], references: [id])

  status        FriendshipStatus @default(PENDING)
  requestedById String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([userA_id, userB_id])
}

// =============================================================================
// üí¨ CHATS AND MESSAGES
// =============================================================================

model ChatRoom {
  id             String    @id @default(uuid())
  type           ChatType  @default(DIRECT)
  name           String?
  isEphemeral    Boolean   @default(false)
  createdAt      DateTime  @default(now())
  lastActivityAt DateTime  @default(now())

  participants   ChatParticipant[]
  messages       Message[]

  isPublic       Boolean   @default(false)
  description    String?

  // –ö–∞–Ω–∞–ª—ã (type = CHANNEL): –≤–ª–∞–¥–µ–ª–µ—Ü, –∫–∞—Ç–µ–≥–æ—Ä–∏—è, –∑–∞–∫—Ä—ã—Ç—ã–π/–ø–æ –∏–Ω–≤–∞–π—Ç—É
  ownerId        String?
  owner          User?     @relation("ChannelOwner", fields: [ownerId], references: [id])
  channelType    String?   // news, entertainment, tech, education, lifestyle, sports, other
  isPrivate      Boolean   @default(false)
  channelInvites ChannelInvite[]
}

// –ò–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫–∏ –¥–ª—è –∑–∞–∫—Ä—ã—Ç—ã—Ö –∫–∞–Ω–∞–ª–æ–≤. –û–¥–∏–Ω —Ç–æ–∫–µ–Ω –Ω–∞ –∫–∞–Ω–∞–ª (–ø–µ—Ä–µ—Å–æ–∑–¥–∞—ë—Ç—Å—è –ø–æ –∑–∞–ø—Ä–æ—Å—É).
model ChannelInvite {
  token      String    @id
  chatRoomId String
  chatRoom   ChatRoom  @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  createdAt  DateTime  @default(now())
  expiresAt  DateTime?

  @@index([chatRoomId])
}

model ChatParticipant {
  userId      String
  chatRoomId  String
  user        User     @relation(fields: [userId], references: [id])
  chatRoom    ChatRoom @relation(fields: [chatRoomId], references: [id])
  joinedAt    DateTime @default(now())

  @@id([userId, chatRoomId])
}

model EmergencyZone {
  id        String   @id // sectorId
  count     Int      // Number of signals
  updatedAt DateTime @updatedAt
  isActive  Boolean  @default(true)
}

// DTN: Backend is append-only global memory. No delivery guarantees; mesh/transport handles delivery.
// Do not add assignedBridge, chainId, delivered_at, lastSeen, online. Do not infer recipient presence.
model Message {
  id           String   @id @default(uuid())
  clientTempId String?  // Idempotency key (client-side). Do not add mesh hash (h) dedup in backend.

  content      String
  createdAt    DateTime @default(now())
  senderId     String
  chatRoomId   String
  expiresAt    DateTime?
  status       MessageStatus @default(SENT) // UI-level only; backend must NOT set DELIVERED/READ automatically.
  isEncrypted  Boolean  @default(false)

  sender   User     @relation(fields: [senderId], references: [id])
  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id])

  @@index([clientTempId])
}

// =============================================================================
// üí∞ GOSSIP ADS MODEL
// =============================================================================

model Ad {
  id          String   @id @default(uuid())
  title       String
  content     String
  imageUrl    String?
  priority    Int      @default(0)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  signature   String?  
}

// =============================================================================
// üõ°Ô∏è EPHEMERAL TOKENS (Anticensorship - mesh anonymity)
// =============================================================================
// Persisted in DB so tokens survive server restart. TTL 1 hour.
model EphemeralToken {
  token     String   @id   // eph_xxx
  userId    String
  expiresAt DateTime

  @@index([expiresAt])  // for cleanup
}

// =============================================================================
// üö® REPORTS
// =============================================================================

model Report {
  id             String       @id @default(uuid())
  reason         String
  description    String?
  status         ReportStatus @default(PENDING)
  
  reporterUserId String
  reportedUserId String
  messageId      String?

  reporterUser   User         @relation("ReportsMadeByUser", fields: [reporterUserId], references: [id])
  reportedUser   User         @relation("ReportsAboutUser", fields: [reportedUserId], references: [id])

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
}

// =============================================================================
// üìã ENUMS
// =============================================================================

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum ChatType {
  DIRECT
  GROUP
  CHANNEL
  GLOBAL
}

// DTN: DELIVERED and READ are UI-level only. Backend must NOT update status to DELIVERED or READ;
// delivery is inferred by client/mesh, not by backend. Backend stores messages append-only.
enum MessageStatus {
  SENT
  DELIVERED  // UI-only; backend must not infer or set delivery.
  READ       // UI-only; backend must not infer or set read.
}

enum ReportStatus {
  PENDING
  RESOLVED
  REJECTED
}